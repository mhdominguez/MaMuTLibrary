#!/usr/bin/perl

# MaMuT split dataset by track filter(s)
# 2019-2021 Martin H. Dominguez
# Gladstone Institutes

# Filter a MaMuT dataset by splitting into 2 datasets (.0.xml and .1.xml), with .0.xml containing rejected tracks/cells, and .1.xml containing filtered tracks/cells according to criteria specified...
# usages: perl MaMuT_dataset_split_track_filter.pl dataset_mamut.xml track_start_min=20 track_stop_max=150 track_duration_min=50 #(filters tracks starting after timepoint 20, ending before timepoint 150, and with minimum duration 50 timeframes
#         perl MaMuT_dataset_split_track_filter.pl dataset_mamut.xml track_displacement_min=5 track_displacement_max=20 #(filters tracks with net displacement between 5 and 20 units)
#         perl MaMuT_dataset_split_track_filter.pl dataset_mamut.xml avg_vel_min=5 avg_vel_max=20 #(filters tracks with average velocity between between 5 and 20 units)
#         perl MaMuT_dataset_split_track_filter.pl dataset_mamut.xml number_splits_max=3 rad_min=4 #(filters tracks with fewer than 3 splits and cell radii greater than 4)
#         perl MaMuT_dataset_split_track_filter.pl dataset_mamut.xml pos_x_min=-40 pos_y_max=200 pos_z_min=-1700 pos_z_max=0 #(filters tracks with cells bounded by max/min coordinates as specified)
#         perl MaMuT_dataset_split_track_filter.pl dataset_mamut.xml ann=spotRadiusAnnotations_20211124T093902_downOnly.txt #(filters tracks with spots on a radius-annotation CSV list i.e. generated by MaMuT_dataset_dataset_export_radius_annotations.pl)

# note this script is single-threaded and slow!




use Cwd qw( cwd );
my $path = Cwd::cwd();

use constant TRUE => 1;
use constant FALSE => 0;

use constant {
	FILTER_FEATURE_TRACK_DURATION => 0,
	FILTER_FEATURE_TRACK_START => 1,
	FILTER_FEATURE_TRACK_STOP => 2,
	FILTER_FEATURE_TRACK_DISPLACEMENT => 3,
	FILTER_FEATURE_TRACK_NUMBER_SPLITS => 4,
	FILTER_FEATURE_TRACK_AVG_VELOCITY => 5,
	
	FILTER_FEATURE_TRACK_MAX => 6,
	
	FILTER_FEATURE_CELL_RADIUS => 6,
	FILTER_FEATURE_CELL_QUALITY => 7,
	FILTER_FEATURE_CELL_POS_X => 8,
	FILTER_FEATURE_CELL_POS_Y => 9,
	FILTER_FEATURE_CELL_POS_Z => 10,
	
	FILTER_FEATURE_CELL_ANNOTATION => 11,
	
	FILTER_FEATURE_CELL_MAX => 12,
};

use constant {
	FILTER_DIRECTION_NOT_USED => 0,
	FILTER_DIRECTION_GT => 1,
	FILTER_DIRECTION_LT => 2,
	#FILTER_DIRECTION_GTEQ => 3,
	#FILTER_DIRECTION_LTEQ => 4,	
	#FILTER_DIRECTION_EQUAL => 5,
	#FILTER_DIRECTION_NE => 6,	
	
	FILTER_DIRECTION_MAX => 3
};

#==================
#Main subroutine
#==================
my @annotated_spot_list;

sub main {
	my $dataset_file = shift;
	my @params = @_;	
	my @lines_main; #unchanging lines during reconstruction
	my $line_number_spots = -1; #indicates where to put <AllSpots> blocks when reconstructing the file at the end
	my @lines_spots;
	my @frames_spots;
	
	my $line_number_tracks = -1; #indicates where to put <AllTracks> blocks when reconstructing the file at the end
	my @lines_tracks;
	#my @track_tracks;
	my @spots_in_tracks;
	my @track_in_tracks;
	my $line_number_filters = -1; #indicates where to put <AllTracks> blocks when reconstructing the file at the end
	my @lines_filters;
	my @track_in_filters;
	
	my $num_bins = 2;

	my @bins_tracks;
	my @track_filter_cutoffs;
	my @track_filter_directions;
	my @track_filter_indices;
	#my @filter_feature_tracks;
	#my $open_block = -1; #will determine actions to take while parsing XML line-by-line
	
	##---------------------------
		#command-line param handler
	##---------------------------		
	my @this_param = ();
	#my $comparator_string;
	my $comparator_value;
	my $track_filter_index;
	for ( my $k=0; $k<scalar(@params); $k++ ) {
		$params[$k] =~ s/==/=/g;
		@this_param = split( /=/, $params[$k] );
		#$comparator_string = $1;
		$comparator_value = FILTER_DIRECTION_NOT_USED;
		if ( $this_param[0] =~ /max/i ) {
			$comparator_value = FILTER_DIRECTION_LT;
		} elsif ( $this_param[0] =~ /min/i ) {
			$comparator_value = FILTER_DIRECTION_GT;
		}
		
		if ( $comparator_value == FILTER_DIRECTION_NOT_USED && $this_param[0] !~ /ann/i ) {
			print "Parameter $params[$k] unknown due to bad comparator, not using.  Please specify valid command line arguments...\n";
			next;
		}
		
		$track_filter_index = -1;
		if ( $this_param[0] =~ /track_start/i && $this_param[1] =~ /^[+-]?\d*\.?\d*([eE][-+]?\d+)?$/ ) {
			$track_filter_index = FILTER_FEATURE_TRACK_START; 
		} elsif ( $this_param[0] =~ /track_stop/i && $this_param[1] =~ /^[+-]?\d*\.?\d*([eE][-+]?\d+)?$/ ) {
			$track_filter_index = FILTER_FEATURE_TRACK_STOP; 
		} elsif ( $this_param[0] =~ /track_displacement/i && $this_param[1] =~ /^[+-]?\d*\.?\d*([eE][-+]?\d+)?$/ ) {
			$track_filter_index = FILTER_FEATURE_TRACK_DISPLACEMENT; 	
		} elsif ( $this_param[0] =~ /track_duration/i && $this_param[1] =~ /^[+-]?\d*\.?\d*([eE][-+]?\d+)?$/ ) {
			$track_filter_index = FILTER_FEATURE_TRACK_DURATION; 
		} elsif ( $this_param[0] =~ /number_splits/i && $this_param[1] =~ /^[+-]?\d*\.?\d*([eE][-+]?\d+)?$/ ) {
			$track_filter_index = FILTER_FEATURE_TRACK_NUMBER_SPLITS; 
		} elsif ( $this_param[0] =~ /(avg|mean|average)_vel/i && $this_param[1] =~ /^[+-]?\d*\.?\d*([eE][-+]?\d+)?$/ ) {
			$track_filter_index = FILTER_FEATURE_TRACK_AVG_VELOCITY;
		} elsif ( $this_param[0] =~ /rad/i && $this_param[1] =~ /^[+-]?\d*\.?\d*([eE][-+]?\d+)?$/ ) {
			$track_filter_index = FILTER_FEATURE_CELL_RADIUS;
		} elsif ( $this_param[0] =~ /qual/i && $this_param[1] =~ /^[+-]?\d*\.?\d*([eE][-+]?\d+)?$/ ) {
			$track_filter_index = FILTER_FEATURE_CELL_QUALITY;
		} elsif ( $this_param[0] =~ /pos/i && $this_param[1] =~ /^[+-]?\d*\.?\d*([eE][-+]?\d+)?$/ ) {
			if ( $this_param[0] =~ /x/i ) {
				$track_filter_index = FILTER_FEATURE_CELL_POS_X;
			} elsif ( $this_param[0] =~ /y/i ) {
				$track_filter_index = FILTER_FEATURE_CELL_POS_Y;
			} elsif ( $this_param[0] =~ /z/i ) {
				$track_filter_index = FILTER_FEATURE_CELL_POS_Z;
			}
		} elsif ( $this_param[0] =~ /ann/i && $this_param[1] =~ /\w/ && -e "$path/$this_param[1]" ) {
			$track_filter_index = FILTER_FEATURE_CELL_ANNOTATION;
			
			if ( open(FILE, "<$path/$this_param[1]" ) ) {
				flock(FILE, LOCK_EX);
				my @file_lines;
				while( <FILE> ) {
					chomp;
					push( @file_lines, $_ );
				}
				flock(FILE, LOCK_UN);
				close(FILE);
				my @line_split;
				for (my $qq=1; $qq<scalar(@file_lines); $qq++ ) { #ignore header line
					@line_split = split( /,/, $file_lines[$qq] );
					push( @annotated_spot_list, [ $line_split[2], $line_split[3] ] ); #timepoint, spotID
				
				}
			} else {
				print "Cannot open annotation file $path/$this_param[1]!\n";
			}
			
			
			
			
			
			$this_param[1] = 0;
			
			
		}
		
		if ( $track_filter_index < 0 ) {
			print "Parameter $this_param[0] unknown ($params[$k]), not using.  Please specify valid command line arguments...\n";
			#return;
		} else {
			push( @track_filter_cutoffs, $this_param[1] );
			push( @track_filter_directions, $comparator_value );
			push( @track_filter_indices, $track_filter_index );
			print "Adding criterion $this_param[0] as $this_param[1] to selection filter...\n";
		}
	}
	undef @this_param;	
	
	#parse dataset.mamut
	if ( defined($dataset_file) && $dataset_file =~ /\w/ && open(FILE, "<$path/$dataset_file" ) ) {
		print "Splitting dataset $dataset_file into two bins, filtering by above criteria.  Command line arguments follow dataset filename.\n";
		flock(FILE, LOCK_EX);
		while( <FILE> ) {
			chomp;
			#if ( $_ =~ /^\s*<.+>$/ ) { #one tag per line encountered on this line
			if ( $_ =~ /(^|^\s+)<AllSpots/ ) {
				push( @lines_main, $_ );
				$line_number_spots = scalar(@lines_main);
				#push( @lines_spots, [ ($_) ] );
				
				while( <FILE> ) {
					chomp;
					if ( $_ =~ /(^|^\s+)<SpotsInFrame.*frame=\"(\d+)\"/i ) {
						push( @frames_spots, $2 );
						my @this_block = ( $_ );
						while( <FILE> ) {
							chomp;
							push( @this_block, $_ );
							last if ( $_ =~ /(^|^\s+)<\/SpotsInFrame/ );
						}
						push( @lines_spots, \@this_block );
					} elsif ( $_ =~ /(^|^\s+)<\/AllSpots/ ) {
						push( @lines_main, $_ );
						#push( @lines_spots, [ ($_) ] );
						last;
					} else {
						#not inside a SpotsInFrame segment, and yet not finished with AllSpots, so do nothing here put keep reading next line
					}
				}
			} elsif ( $_ =~ /(^|^\s+)<AllTracks/ && $_ !~ /\/>\s*$/ ) {
				push( @lines_main, $_ );
				$line_number_tracks = scalar(@lines_main);
				#push( @lines_tracks, [ ($_) ] );
				while( <FILE> ) {
					chomp;
					if ( $_ =~ /(^|^\s+)<Track.*?TRACK_ID=\"(\d+)\"/ ) {
						
						my $this_track_id = $2;
						my @this_block = ( $_ );
						my @track_feature = ();
						if ( $_ =~ /TRACK_DURATION=\"(\d+\.?\d*)\"/ ) {
							$track_feature[FILTER_FEATURE_TRACK_DURATION] = $1;
						}
						if ( $_ =~ /TRACK_START=\"(\d+\.?\d*)\"/ ) {
							$track_feature[FILTER_FEATURE_TRACK_START] = $1;
						}
						if ( $_ =~ /TRACK_STOP=\"(\d+\.?\d*)\"/ ) {
							$track_feature[FILTER_FEATURE_TRACK_STOP] = $1;
						}
						if ( $_ =~ /TRACK_DISPLACEMENT=\"(\d+\.?\d*)\"/ ) {
							$track_feature[FILTER_FEATURE_TRACK_DISPLACEMENT] = $1;
						}
						if ( $_ =~ /NUMBER_SPLITS=\"(\d+\.?\d*)\"/ ) {
							$track_feature[FILTER_FEATURE_TRACK_NUMBER_SPLITS] = $1;
						}
						if ( defined($track_feature[FILTER_FEATURE_TRACK_DISPLACEMENT]) && defined($track_feature[FILTER_FEATURE_TRACK_DURATION]) && $track_feature[FILTER_FEATURE_TRACK_DURATION] =~ /\d/ && $track_feature[FILTER_FEATURE_TRACK_DISPLACEMENT] =~ /\d/ && $track_feature[FILTER_FEATURE_TRACK_DURATION] > 0 ) {
							$track_feature[FILTER_FEATURE_TRACK_AVG_VELOCITY] = $track_feature[FILTER_FEATURE_TRACK_DISPLACEMENT] / $track_feature[FILTER_FEATURE_TRACK_DURATION];
						}
						
						#print "inside here: $this_track_id\n";
						while( <FILE> ) {
							chomp;
							push( @this_block, $_ );
							if ( $_ =~ /(^|^\s+)<\/Track/ ) {
								last;
							} elsif ($_ =~ /(^|^\s+)<Edge/) { #store all spots associated with this track for reconstruction
								if ( $_ =~ /SPOT_SOURCE_ID=\"(\d+)\".*?SPOT_TARGET_ID=\"(\d+)\"/ ) {
									#print "here\n";
									push( @{$spots_in_tracks[scalar(@lines_tracks)]}, $1, $2 );
								}
							}
						}
						#print "scalar " . scalar(@{$spots_in_tracks[scalar(@lines_tracks)]}) . "\n";
						@{$spots_in_tracks[scalar(@lines_tracks)]} = uniq(@{$spots_in_tracks[scalar(@lines_tracks)]});
						$track_in_tracks[scalar(@lines_tracks)] = $this_track_id;

						#criteria testing here
						$bins_tracks[scalar(@lines_tracks)] = 1; #pass everything by default
						for ( my $i=0; $i<scalar(@track_filter_indices); $i++ ) {
							if ( $track_filter_directions[$i] <= FILTER_DIRECTION_NOT_USED || $track_filter_indices[$i] >= FILTER_FEATURE_TRACK_MAX ) { #pass all the cell-based (not track-based) criteria
								 next;
							} elsif ( $track_filter_directions[$i] == FILTER_DIRECTION_GT) {
								if ( $track_feature[$track_filter_indices[$i]] < $track_filter_cutoffs[$i] ) {
									$bins_tracks[scalar(@lines_tracks)] = 0; #fail
									last;
								}
								next;
							} elsif ( $track_filter_directions[$i] == FILTER_DIRECTION_LT) {
								if ( $track_feature[$track_filter_indices[$i]] > $track_filter_cutoffs[$i] ) {
									$bins_tracks[scalar(@lines_tracks)] = 0; #fail
									last;
								}
								next;								
							} 
						}

						push( @lines_tracks, \@this_block );
					} elsif ( $_ =~ /(^|^\s+)<\/AllTracks/ ) {
						#push( @lines_tracks, [ ($_) ] );
						push( @lines_main, $_ );
						last;
					} else {
						#not inside a Track segment, and yet not finished with AllTracks, so do nothing here put keep reading next line
					}
				}
			} elsif ( $_ =~ /(^|^\s+)<FilteredTracks/ && $_ !~ /\/>\s*$/ ) {
				push( @lines_main, $_ );
				$line_number_filters = scalar(@lines_main);
				#push( @lines_filters, [ ($_) ] );
				while( <FILE> ) {
					chomp;
					if ( $_ =~ /(^|^\s+)<\/FilteredTracks/ ) {
						push( @lines_main, $_ );	
						last;
					} elsif ( $_ =~ /TRACK_ID=\"(\d+)\"/ ) {
						#within FilteredTracks segment
						push( @track_in_filters, $1 );						
						push( @lines_filters, $_ );
					}
				}	
			} else {
				push( @lines_main, $_ );
			}

		}
		flock(FILE, LOCK_UN);
		close(FILE);
	} else {
		print "Error opening $path/$dataset_file!\n";
		return;
	}
	
	#remove all track-based criteria, saving cell-based criteria here
	for ( my $i=scalar(@track_filter_indices)-1; $i>=0; $i-- ) {
		 if ($track_filter_indices[$i] < FILTER_FEATURE_TRACK_MAX) {
		 	splice( @track_filter_indicies, $i, 1 );
		 	splice( @track_filter_directions, $i, 1 );
		 	splice( @track_filter_cutoffs, $i, 1 );
		 }
	}
	
	#return;
	#strip filename of extension, and assume it is XML
	( undef, $dataset_file ) = split( /\./, reverse($dataset_file), 2 );
	$dataset_file = reverse($dataset_file);
	#print join( "\n", @lines_main );
	#print join( "\n", @track_in_tracks );
	#print "Number of main lines: " . scalar(@lines_main) . ", number of spots lines: " . scalar(@lines_spots) . ", number of tracks lines: " . scalar(@lines_tracks) . ", number of filtered tracks lines: " . scalar(@lines_filters) . "\n";
	#map { print $_->[0] . "..." . $->[scalar(@{$_})-1] . "\n"; } @lines_spots;
	#map { print $_->[scalar(@{$_})-1] . "\n"; } @lines_spots;
	#return;
	
	##iterate over spots over all time points to determine mean Z coordinate
	#my @this_line;
	##my $num_spots = 0;
	##my $sum_spots =0;
	#my @spot_coordinates;
	#for ( my $i=0; $i<scalar(@lines_spots); $i++ ) {
	#	for ( my $k=0; $k<scalar(@{$lines_spots[$i]}); $k++ ) {
	#		if ( $lines_spots[$i][$k] =~ /<Spot/ && $lines_spots[$i][$k] =~ /POSITION_Z=\"([+-]?\d+(\.?\d*))\"/ ) {
	#			#capture $1 to store position Z in string form, then immediately use in float sum
	#			#$sum_spots += $1;
	#			#$num_spots++;
	#			push( @spot_coordinates, $1 );
	#		}
	#	}
	#}
	#
	##write median Z to $mean_z
	#@spot_coordinates = sort { $a <=> $b } @spot_coordinates;#{ $a cmp $b };
	#my $mean_z;
	#if ( scalar(@_) & 1 ) { #odd number of numbers
	#	my $med = int( scalar(@spot_coordinates)/2);
	#	$mean_z = $spot_coordinates[$med];
	#	#$med = "me!";
	#} else {
	#	my $med = scalar(@spot_coordinates) / 2;
	#	$mean_z = ( $spot_coordinates[$med] + $spot_coordinates[$med -1] ) / 2;
	#}	
	##my $mean_z = $sum_spots/$num_spots;
	##print "mean Z: " . $sum_spots/$num_spots . ", " . $num_spots . "\n"; return;
	#unless( defined($mean_z) && $mean_z =~ /\d/ ) {
	#	print "Could not determine median Z from spot coordinates.  Aborting.\n"
	#	return;
	#}
	
	#iterate over spots at t=0, subdivide them, while storing IDs for tree reconstruction
	my @lines_spots_divided; #final storage for subdivisions, 3D matrix [timepoint][subdivision][spot], compared with 2D matrix of @lines_spots [timepoint][spot]
	my @lines_spots_control_blocks_undivided;
	#my @tracking_spots_divided; # storage for spot IDs undergoing lineage reconstruction by the splitting algorithm, 2D matrix [subdivision][spotID], each spotID will be removed once the daughter spot is found and added to @lines_spots_divided
	my $this_spot_id;
	my $this_bin;
	##print "t=0, total spots handled: " . scalar(@{$lines_spots[0]}) . "\n";
	#for ( my $k=scalar(@{$lines_spots[0]})-1; $k>=0; $k-- ) {
	#	if ( $lines_spots[0][$k] =~ /<Spot/ && $lines_spots[0][$k] =~ /ID=\"(\d+)\"/ ) {
	#		#capture ID
	#		$this_spot_id = $1;
	#		if ($lines_spots[0][$k] =~ /POSITION_Z=\"([+-]?\d+(\.?\d*))\"/ ) {
	#			$this_bin = int(rand()*$num_bins);
	#			unshift( @{$lines_spots_divided[0][$this_bin]}, $lines_spots[0][$k] );
	#			#unshift( @{$tracking_spots_divided[$this_bin]}, $this_spot_id );
	#			#print "about to iterate over " . scalar(@spots_in_tracks) . "\n";
	#			#now find any tracks belonging to this spot, place track in the the divided bin, and add all associated spots to the @tracking_spots_divided bin
	#			for ( my $l =0; $l<scalar(@spots_in_tracks); $l++ ) {
	#				#print "  about to iterate over " . scalar(@{$spots_in_tracks[$l]}) . "\n";
	#				for ( my $j=scalar(@{$spots_in_tracks[$l]})-1; $j>0; $j-- ) {
	#					#print "testing $spots_in_tracks[$l][$j] eq $this_spot_id\n";
	#					if ( $spots_in_tracks[$l][$j] eq $this_spot_id ) {
	#						splice( @{$spots_in_tracks[$l]}, $j, 1 ); #already dealt with this spot, so remove it
	#						#push( @{$tracks_divided[$this_bin]}, splice(@lines_tracks, $l, 1) );
	#						$bins_tracks[$l] = $this_bin;
	#						#print "assigning $this_bin to track $track_in_tracks[$l]\n";
	#						last;
	#					}
	#				}
	#			}
	#
	#		}
	#	} else {
	#		#control blocks get passed to both divisions
	#		for (my $l=0; $l<$num_bins; $l++ ) {
	#			unshift( @{$lines_spots_divided[0][$l]}, $lines_spots[0][$k] );
	#		}
	#	}
	#}
	#undef @{$lines_spots[0]}; #start freeing space
	##print "join " . join("\n", @{$lines_spots[0]}) . "\n";
	##print "num spots in each division: " . scalar(@{$lines_spots_divided[0][0]}) . ", " .  @{$lines_spots_divided[0][1]} . "\n";
	##return;
	#iterate over all spots in time, reconstructing lineages and sorting tracks to the correct bins
	my $this_track; my $this_spot_in_track;
	my $going;
	for ( my $i=0; $i<scalar(@lines_spots); $i++ ) {
		#print "t=$i, total spots handled: " . scalar(@{$lines_spots[$i]}) . "\n";
		#do control blocks, assuming only one line at beginning and one at end
		push( @lines_spots_control_blocks_undivided, [($lines_spots[$i][0],$lines_spots[$i][scalar(@{$lines_spots[$i]})-1])] );
		
		#now do spot lines, ignoring the first and last lines as control blocks
		for ( my $k=scalar(@{$lines_spots[$i]})-2; $k>0; $k-- ) {
			if ( $lines_spots[$i][$k] =~ /<Spot/ && $lines_spots[$i][$k] =~ /ID=\"(\d+)\"/ ) {
				#capture ID

				$this_spot_id = $1;
				$this_bin = -1;
				#print "  setting up $this_spot_id\n";
				#try to find this ID within tracks for either bin already decided
				$going = FALSE;
				for ( my $l=0; $l<scalar(@spots_in_tracks); $l++ ) {
					#print "   looking in track $track_in_tracks[$l] ($l)...\n";
					next if ($bins_tracks[$l] < 0);
					#print "Looking at spot $i / $k / $l, which belongs in bin $bins_tracks[$l]...\n";
					#print "   looking in track $track_in_tracks[$l] ($l)...\n";
					for ( my $j=scalar(@{$spots_in_tracks[$l]})-1; $j>=0; $j-- ) {
						if ( $spots_in_tracks[$l][$j] eq $this_spot_id ) {			
							splice( @{$spots_in_tracks[$l]}, $j, 1 ); #already dealt with this spot, so remove it
							#push( @{$tracks_divided[$this_bin]}, splice(@lines_tracks, $l, 1) );
							#print "    found spot $this_spot_id in track #$l, track $track_in_tracks[$l], position $j\n";
							$going = TRUE;
							if ( scalar(@track_filter_directions) > 0 && $bins_tracks[$l] > 0) { #if track has already failed, don't bother with this step
								#$going = TRUE; #pass by default, when criterion is missed, then fail and exit loop -- this already done above
								for ( my $c=0; $c<scalar(@track_filter_directions); $c++ ) {
									if ( test_spot_criteria( $lines_spots[$i][$k], $track_filter_indices[$c], $track_filter_directions[$c], $track_filter_cutoffs[$c] ) == 0 ) { #failed
										$bins_tracks[$l] = 0;
										last;
									}
								}
				
				
							}							
							push( @spots_to_bin, [ ( $i, $k, $l )] ); #store a record of this spot
							#unshift( @{$lines_spots_divided[$i][$this_bin]}, $lines_spots[$i][$k] ); #do this later
							
							last;
						}
					}
					last if ( $going );
				}
				
				if ( $this_bin < 0 && $lines_spots[$i][$k] =~ /POSITION_Z=\"([+-]?\d+(\.?\d*))\"/ ) { #spot not assigned to track, so put it in the lower subdivision
					$this_bin = 0; 
					if ( scalar(@track_filter_directions) > 0 && scalar(@lines_tracks) < 1) {
						$this_bin = 1;  #when cell features are in play, and NO tracks are present (i.e. this is a static single-frame image), spots not assigned to tracks can pass into upper subdivision if they meet criteria
						for ( my $c=0; $c<scalar(@track_filter_directions); $c++ ) {
							if ( test_spot_criteria( $lines_spots[$i][$k], $track_filter_indices[$c], $track_filter_directions[$c], $track_filter_cutoffs[$c] ) == 0 ) { #failed
								$this_bin = 0;
								last;
							}
						}
					}
					#unshift( @{$lines_spots_divided[$i][$this_bin]}, $lines_spots[$i][$k] ); #okay to do this here since track not being considered
					#unshift( @{$tracking_spots_divided[$this_bin]}, $this_spot_id );
					
					#since we didn't already have an assignment of a track (all tracks already come with assigned $this_bin), don't even bother looking
					##now find any tracks belonging to this spot, place track in the the divided bin, and add all associated spots to the @tracking_spots_divided bin
					#for ( my $l =0; $l<scalar(@spots_in_tracks); $l++ ) {
					#	for ( my $j=scalar(@{$spots_in_tracks[$l]})-1; $j>0; $j-- ) {
					#		if ( $spots_in_tracks[$l][$j] eq $this_spot_id ) {
					#			splice( @{$spots_in_tracks[$l]}, $j, 1 ); #already dealt with this spot, so remove it
					#			#push( @{$tracks_divided[$this_bin]}, splice(@lines_tracks, $l, 1) );
					#			$bins_tracks[$l] = $this_bin;
					#			last;
					#		}
					#	}
					#}
				}
			}# else {
			#	#control blocks get passed to both divisions
			#	for (my $l=0; $l<$num_bins; $l++ ) {
			#		unshift( @{$lines_spots_divided[$i][$l]}, $lines_spots[$i][$k] );
			#	}
			#}
		}
		#undef @{$lines_spots[$i]}; #freeing space
	}

	#now, bin all spots correctly
	my @this_spot_to_bin;
	for ( my $q=0; $q<scalar(@spots_to_bin); $q++ ) {
		@this_spot_to_bin = @{$spots_to_bin[$q]};
		
		#print "Binning spot $this_spot_to_bin[0] / $this_spot_to_bin[1] / $this_spot_to_bin[2] to $bins_tracks[$this_spot_to_bin[2]]...\n";
		unshift( @{$lines_spots_divided[$this_spot_to_bin[0]][$bins_tracks[$this_spot_to_bin[2]]]}, $lines_spots[$this_spot_to_bin[0]][$this_spot_to_bin[1]] );
	}
	
	#divide the tracks according to bin numbers assigned above -- most likely this code section could be incorporated into file out below, but for now will leave it here
#	my @tracks_divided; #final storage for tracks [subdivision][tracks]
#	my @filters_divided;
#	for ( my $i=scalar(@bins_tracks)-1; $i>=0; $i-- ) {
#		push( @{$tracks_divided[$bins_tracks[$i]]}, splice(@lines_tracks, $i, 1) );
#		for ( my $k=0; $k<scalar(@lines_filters); $k++ ) { #dont worry about working backwards and splicing because this segment takes up very little memory
#			push( @{$filters_divided[$bins_tracks[$i]]}, $lines_filters[$k] );		
#		}
#	}
	
	
	#check for Track_0 and identify the bin it belongs to -- needed so MaMuT still works
	#$this_bin = -1;
	#for ( my $i=0; $i<scalar(@lines_tracks); $i++ ) {
	#	if ( $lines_tracks[$i] =~ /TRACK_ID="0+"/ && $lines_tracks[$i] =~ /TRACK_INDEX="0+"/i ) {
	#		$this_bin = $bins_tracks[$i];
	#		last;
	#	}
	#}
	
	#finally, for each subdivision, update nspots, update track_0 in this bin, and write file
	my $nspots_divided = ( 0 ) x $num_bins;
	for (my $l=0; $l<$num_bins; $l++ ) {
	
		#update nspots
		for ( my $i=0; $i<scalar(@lines_spots_divided); $i++ ) {
			$nspots_divided[$l] += scalar(@{$lines_spots_divided[$i][$l]})-1;
		}
		for ( my $fl=0; $fl<scalar(@lines_main); $fl++ ) { #look to find and update nspots
			if ( $lines_main[$fl] =~ /(^|^\s+)<AllSpots/ ) {
				$lines_main[$fl] =~ s/nspots=\"(\d+)\"/nspots=\"$nspots_divided[$l]\"/;
			}
		}
		
		##rename last track to track_0 unless already in this bin
		#unless ( $this_bin == $l ) {
		#	for ( my $i=scalar(@lines_tracks)-1; $i>=0; $i-- ) {
		#		#rename last track as track_0
		#		if ( $bins_tracks[$i] == $l && $lines_tracks[$i][0] =~ /TRACK_ID="(\d+)"/ && $lines_tracks[$i][0] =~ /TRACK_INDEX="(\d+)"/i ) {
		#			#$this_spot_id = $1;
		#			$lines_tracks[$i][0] =~ s/TRACK_ID="(\d+)"/TRACK_ID="0"/;
		#			$lines_tracks[$i][0] =~ s/TRACK_INDEX="(\d+)"/TRACK_INDEX="0"/;
		#			
		#			#now go back through FilteredTracks and find this ID to change to 0
		#			for ( my $k=scalar(@lines_filters)-1; $k>=0; $k-- ) {
		#				if ( $track_in_tracks[$i] eq $track_in_filters[$k] ) {
		#					$lines_filters[$k] =~ s/TRACK_ID="(\d+)"/TRACK_ID="0"/;
		#					last;
		#				}
		#			}
		#			
		#			last;
		#		}	
		#	}
		#}
		
		if ( open(FILE, ">$path/$dataset_file\.$l\.xml" ) ) {
			flock(FILE, LOCK_EX);
			for ( my $fl=0; $fl<scalar(@lines_main); $fl++ ) {
				if ( $fl == $line_number_spots ) {
					for ( my $i=0; $i<scalar(@lines_spots_divided); $i++ ) {
						print FILE $lines_spots_control_blocks_undivided[$i][0] . "\n";
						for ( my $k=0; $k<scalar(@{$lines_spots_divided[$i][$l]}); $k++ ) {
							print FILE $lines_spots_divided[$i][$l][$k] . "\n";
						}
						print FILE $lines_spots_control_blocks_undivided[$i][1] . "\n";
					}
				} elsif ( $fl == $line_number_tracks ) {
					#for ( my $i=0; $i<scalar(@{$tracks_divided[$l]}); $i++ ) {
					#	print FILE $tracks_divided[$l][$i] . "\n";
					#}
					for ( my $i=0; $i<scalar(@lines_tracks); $i++ ) {
						if ( $bins_tracks[$i] == $l ) {
							print FILE join( "\n", @{$lines_tracks[$i]} ) . "\n";
						}
					}
				} elsif ( $fl == $line_number_filters ) {
					for ( my $i=0; $i<scalar(@lines_tracks); $i++ ) {
						if ( $bins_tracks[$i] == $l ) {
							for ( my $k=0; $k<scalar(@lines_filters); $k++ ) {
								if ( $track_in_tracks[$i] eq $track_in_filters[$k] ) {
									print FILE $lines_filters[$k] . "\n";
									last;
								}
							}
						}
					}	
				}
				print FILE $lines_main[$fl] . "\n";
			}
			flock(FILE, LOCK_UN);
			close(FILE);
		} else {
			print "Error writing to $path/$dataset_file\.$l\.xml!\n";
			return;
		}		
	}
}


sub test_spot_criteria {
	my ( $line_text, $parameter_index, $parameter_direction, $parameter_cutoff ) = @_;
#return 1;
	my $value;
	if ( $parameter_index eq FILTER_FEATURE_CELL_ANNOTATION && scalar(@annotated_spot_list) > 0 && $line_text =~ /ID=\"(.*?)\"/ ) {
		my $id = $1;
		for ( my $k=$#annotated_spot_list; $k>=0; $k-- ) {
			if ( $annotated_spot_list[$k][1] eq $id && $line_text =~ /POSITION_T=\"(.*?)\"/ ) {
				if ( $1 == $annotated_spot_list[$k][0] ) {
					#we found the spot
					splice(@annotated_spot_list,$k,1); #remove so we don't look for it anymore
					return 0;
				}
			}
		}
	}
	
	if ( $parameter_index eq FILTER_FEATURE_CELL_RADIUS ) {
		$value = $1 if ( $line_text =~ /RADIUS=\"(\d+\.?\d*)\"/ );
		#print "Comparing radius $value versus $parameter_cutoff...\n";
	} elsif ( $parameter_index eq FILTER_FEATURE_CELL_QUALITY ) {
		$value = $1 if ( $line_text =~ /QUALITY=\"(\d+\.?\d*)\"/ );
	} elsif ( $parameter_index eq FILTER_FEATURE_CELL_POS_X ) {
		$value = $1 if ( $line_text =~ /POSITION_X=\"(\d+\.?\d*)\"/ );
	} elsif ( $parameter_index eq FILTER_FEATURE_CELL_POS_Y ) {
		$value = $1 if ( $line_text =~ /POSITION_Y=\"(\d+\.?\d*)\"/ );
	} elsif ( $parameter_index eq FILTER_FEATURE_CELL_POS_Z ) {
		$value = $1 if ( $line_text =~ /POSITION_Z=\"(\d+\.?\d*)\"/ );
	} else {
		return 1; #TRUE, default return
	}

	return 1 unless ( defined($value) && $value =~ /\d/ );

	if ( $parameter_direction == FILTER_DIRECTION_GT) {
		return 0 if ( $value < $parameter_cutoff);
	} elsif ( $parameter_direction == FILTER_DIRECTION_LT) {
		return 0 if ( $value > $parameter_cutoff);
	} else {
		return 1;
	}
	#print "  ...passed\n";
	return 1;
}

#==================
#Array remove duplicates
#==================
sub uniq {
    my %seen;
    grep !$seen{$_}++, @_;
}


#==================
#Comparison subroutines
#==================
sub max {
	my $max = shift;
	$max = $max > $_ ? $max : $_ for @_;
	return $max
}

sub min {
	my $min = shift;
	$min = $min < $_ ? $min : $_ for @_;
	return $min
}

#print "Entered perl...\n";
main(@ARGV);


